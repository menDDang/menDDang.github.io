---
layout: post
title: C Study
categories: C

---

# C udemy 강의 수강 기록 저장소

## #7. 2022.05.22 (126, 127, 128, 129, 130, 131, 132)
 
* 배열 참조시에 
   for (int i = 0; i < length; i++) { sum += a[i]; }
  보다
   p_arr = arr;
   end = arr[length];
   while (p_arr < end) { sum += *p++; }
  를 사용하는것이 아주 조금이나마 빠름.
* 요즘은 컴파일러가 최적화를 잘해주기때문에 성능차이가 없을 수 있지만,
  포팅을 생각한다면 후자의 경우를 사용하는것이 좋아보임.
* const 키워드를 포인터 변수에 사용할 경우, 주소값을 변경못하는 경우와 메모리값을 변경못하는 경우 두가지가 존재
  const int* p  --> 메모리 값 변경 금지
  int const* p  --> 주소 값 변경 금지
  
## #6. 2022.05.22 (105, 106, 107, 108)

* 유효하지 않은 주소를 가리키고 있는 포인터를 "dangling pointer"라고 부름.
* 잘못된 주소를 가리키고 있으면, 의도치않은 에러가 발생할 수 있으니 절대 사용하지 말아야함.
* 함수가 포인터를 반환하면 dangling pointer가 생길수 있으니 반환하면 안되지만,
  아래의 경우에는 주소값을 반환해도 괞찮음.
    - 전역변수
    - 함수 내에 있는 static 변수
    - 파일 속 static 전역 변수
    - 힙 메모리에 존재하는 변수
  ==> 즉, 함수 스택 프레임내에 존재하지 않는 변수의 경우에는 사용이 가능함
* 아무것도 가리키고 있지 않은 포인터를 NULL 포인터라 부름.
* 0 값으로 초기화되어 있는 포인터 == NULL 포인터
* 전용 매크로가 존재, '#define NULL ((void*)0)'
* NULL 포인터가 함수 매개변수로 입력될 경우 문제가 생길 가능성이 매우 높음
  따라서, 함수의 선 조건으로 모든 함수는 NULL이 입력되지 않을것이라고 정의한 후에 코딩하면 좋음.
  **만약 매개변수에 null이 입력될 수 있으면 변수명에 null이 입력될 수 있음을 명시하자.**

## #5. 2022.05.22 (79, 80, 81)

* extern 키워드를 사용하면 외부에서 전역변수에 접근이 가능하고, 심지어는 값을 변경할 수도 있음.
* 전역변수를 외부에서 접근이 불가능하도록 제한하고 싶을 경우에, 전역변수에 static 키워드를 사용.
* 파일안에만 "고정" 되어있다는 의미로 static 키워드를 사용하면 다른 파일에서 접근이 불가능해짐.

## #4. 2022.05.22 (76, 77, 78)

* 서로 다른 .c 파일에서 같은 이름의 전역 변수 사용시 링커가 에러를 내뱉음 (컴파일은 가능)
* 이를 해결하기 위해, extern 키워드를 사용하여 링커에게 어딘가에 해당 전역변수가 있음을 알려줘야 함.
* 함수 전방 선언과 유사한 기능

## #3. 2022.05.15 (55, 56, 57)

* Thread 마다 별도의 stack 존재 --> 각 thread에서 함수가 호출되면 서로 다른 thread를 사용.
  (thread가 생성될 때 os가 새로운 스택을 생성해서 할당해 줌)
* clang-windows 사용시 스텍의 최대 크기는 1MB 정도
* 재귀 함수 사용하면 stack의 용량이 부족해질 가능성이 높아짐


## #2. 2022.05.13 (87. 포인터, 88. 주소 연산자 &, 89. 메모리 주소 저장하기, 90. 포인터의 의미, 91. 메모리 주소에 저장된 자료형)

* 포인터(pointer)는 메모리 주소를 저장할 수 있는 자료형.
* OS (Operating System) 에 따라 다르지만, 64 bit 경우 포인터의 크기는 32 bit (4 bytes)를 사용한다.
* 주소를 알아낼 때에는 &를 사용하고, 포인터를 선언할 때에는 * 를 사용한다.


## #1. 2022.05.11 (54. 스택 메모리, 55. 스택 메모리에대해서 간단히 알아보자!)

* 프로그램 실행시 생성되는 메모리는 주소값이 낮은 곳부터 큰 곳의 순서대로 코드, 데이터, 힙, 스택으로 구성된다.
* 각 메모리는 연속된 메모리 상에 존재할 수도 있지만, os에 따라 파편화되어 존재할 수도 있다.
* 프로그램은 main() 함수부터 실행되므로, 스텍의 처음 부분은 main() 함수가 사용하는 local 메모리 등이 포함되어 있다.
* 함수가 호출될 때마다 스텍에 메모리가 할당되며, 복사가 수행된다.
